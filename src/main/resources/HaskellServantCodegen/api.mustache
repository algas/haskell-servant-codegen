{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}

{{#operations}}
module {{package}}.{{classname}} where
{{/operations}}
{{host}}

import Data.Proxy
import Servant.API
import Servant.Client
import Network.URI (URI (..), URIAuth (..), parseURI)
import Data.Maybe (fromMaybe)
import Servant.Common.Text
import Data.List (intercalate)
import qualified Data.Text as T

{{#imports}}import {{import}}
{{/imports}}

instance ToText [String] where
    toText = T.pack . intercalate ","

{{#operations}}
type {{classname}} = {{#operation}}{{& nickname}} -- {{operationId}}{{#hasMore}}
    :<|> {{/hasMore}}{{/operation}}
{{/operations}}

proxy :: Proxy {{classname}}
proxy = Proxy

{{#operations}}

serverPath :: String
serverPath = "{{basePath}}"

parseHostPort :: String -> (String, Int)
parseHostPort path = (host,port)
    where
        authority = case parseURI path of
            Just x -> uriAuthority x
            _      -> Nothing
        (host, port) = case authority of
            Just y -> (uriRegName y, (getPort . uriPort) y)
            _      -> ("localhost", 8080)
        getPort p = case (length p) of
            0 -> 80
            _ -> (read . drop 1) p

(host, port) = parseHostPort serverPath

{{#operation}}
{{operationId}}{{#hasMore}}
    :<|> {{/hasMore}}{{/operation}}
{{/operations}}
    = client proxy $ BaseUrl Http host port

