{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}

{{#operations}}
module {{package}}.{{classname}} (
      {{#operation}}{{operationId}}{{#hasMore}}
    , {{/hasMore}}{{/operation}}
    , proxy{{classname}}
    ) where
{{/operations}}

import GHC.Generics
import Data.Proxy
import Servant.API
import Servant.Client
import Network.URI (URI (..), URIAuth (..), parseURI)
import Data.Maybe (fromMaybe)
import Servant.Common.Text
import Data.List (intercalate)
import qualified Data.Text as T

{{#imports}}import {{import}}
{{/imports}}

instance ToText [String] where
    toText = T.pack . intercalate ","

lkp inputs l = case lookup l inputs of
        Nothing -> Left $ "label " ++ T.unpack l ++ " not found"
        Just v  -> Right $ read (T.unpack v)

{{#operations}}
{{#operation}}
{{#hasFormParams}}
data Form{{#formParams}}{{baseName}}{{/formParams}} = Form{{#formParams}}{{baseName}}{{/formParams}}
    { {{#formParams}}{{baseName}} :: {{dataType}}{{#hasMore}}
    , {{/hasMore}}{{/formParams}}
    } deriving (Show, Eq, Generic)

instance FromFormUrlEncoded Form{{#formParams}}{{baseName}}{{/formParams}} where
--    fromFormUrlEncoded = return
--    fromFormUrlEncoded inputs = Form{{#formParams}}{{baseName}}{{/formParams}} <$> {{#formParams}}lkp inputs "{{baseName}}"{{#hasMore}} <*> {{/hasMore}}{{/formParams}}
instance ToFormUrlEncoded Form{{#formParams}}{{baseName}}{{/formParams}} where
--    toFormUrlEncoded = Prelude.id

{{/hasFormParams}}
{{/operation}}
{{/operations}}

{{#operations}}
type {{classname}} = {{#operation}}{{& nickname}} -- {{operationId}}{{#hasMore}}
    :<|> {{/hasMore}}{{/operation}}
{{/operations}}

proxy{{classname}} :: Proxy {{classname}}
proxy{{classname}} = Proxy

{{#operations}}

serverPath :: String
serverPath = "{{basePath}}"

parseHostPort :: String -> (String, Int)
parseHostPort path = (host,port)
    where
        authority = case parseURI path of
            Just x -> uriAuthority x
            _      -> Nothing
        (host, port) = case authority of
            Just y -> (uriRegName y, (getPort . uriPort) y)
            _      -> ("localhost", 8080)
        getPort p = case (length p) of
            0 -> 80
            _ -> (read . drop 1) p

(host, port) = parseHostPort serverPath

{{#operation}}
{{operationId}}{{#hasMore}}
    :<|> {{/hasMore}}{{/operation}}
    = client proxy{{classname}} $ BaseUrl Http host port
{{/operations}}
